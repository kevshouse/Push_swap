=== ./tests/test_utils/test_helpers.c ===

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_helpers.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kevin-anderson <kevin-anderson@student.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 18:44:09 by kevin-ander       #+#    #+#             */
/*   Updated: 2025/05/14 18:51:59 by kevin-ander      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "test_helpers.h"

void assert_stack_contents(t_stack *s, int expected[], int size)
{
    t_node *current = s->head;
    int i = 0;
    
    while (i < size && current != NULL)
    {
        cr_assert_eq(current->data, expected[i],
                   "Value mismatch at position %d: expected %d, got %d",
                   i, expected[i], current->data);
        current = current->next;
        i++;
    }
    cr_assert_eq(i, size, "Stack size mismatch: expected %d, got %d", size, i);
    cr_assert_null(current, "Stack contains more elements than expected");
}

t_stack *create_test_stack(int values[], int count)
{
    t_stack *s = malloc(sizeof(t_stack));
    stack_init(s);
    
    for (int i = 0; i < count; i++)
        push(s, values[i]);
    
    return s;
}

void destroy_test_stack(t_stack *s)
{
    stack_clear(s);
    free(s);
}

void print_stack_contents(t_stack *s, const char *stack_name)
{
    printf("[%s] Size: %d\n", stack_name, s->size);
    printf("Contents: ");
    
    t_node *current = s->head;
    while (current)
    {
        printf("%d ", current->data);
        current = current->next;
    }
    printf("\n");
}
=== ./tests/test_utils/test_helpers.h ===

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_helpers.h                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kevin-anderson <kevin-anderson@student.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/07/04 14:32:12 by kevin-ander       #+#    #+#             */
/*   Updated: 2025/05/14 18:47:03 by kevin-ander      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef TEST_HELPERS_H
# define TEST_HELPERS_H

# include <criterion/criterion.h>
# include "../includes/p_s_machine.h"

/* Stack Verification Helpers */
void    assert_stack_contents(t_stack *s, int expected[], int size);
void    assert_stack_empty(t_stack *s);
void    assert_stack_size(t_stack *s, int expected_size);

/* Test Setup/Teardown Helpers */
t_stack *create_test_stack(int values[], int count);
void    destroy_test_stack(t_stack *s);

/* Debugging Helpers */
void    print_test_header(const char *test_name);
void    print_stack_contents(t_stack *s, const char *stack_name);

/* Error Case Helpers */
void    test_invalid_operations(t_stack *s);

/* Memory Helpers */
void    check_for_leaks(void);

#endif
=== ./tests/test_stack_ops.c ===

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_stack_ops.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kevin-anderson <kevin-anderson@student.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 18:13:13 by kevin-ander       #+#    #+#             */
/*   Updated: 2025/05/14 19:06:11 by kevin-ander      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <criterion/criterion.h>
#include <criterion/new/assert.h>
#include "p_s_machine.h"
#include "test_utils/test_helpers.h"

TestSuite(stack_operations, .init = NULL, .fini = NULL);

/* -- Helper Functions -- */
static void init_stack(t_stack *s, int values[], int count)
{
    stack_init(s);
    for (int i = 0; i < count; i++) {
        push(s, values[i]);
    }
}

/* -- Test Cases -- */

/* Initialization Test */
Test(stack_operations, stack_init_works)
{
    t_stack s;
    stack_init(&s);
    
    cr_assert_null(s.head);
    cr_assert_null(s.tail);
    cr_assert_eq(s.size, 0);
    
    stack_clear(&s);
}

/* Push/Pop Tests */
Test(stack_operations, push_pop_operations)
{
    t_stack s;
    int values[] = {10, 20, 30};
    
    init_stack(&s, values, 3);
    cr_assert_eq(s.size, 3);
    
    cr_assert_eq(pop(&s), 30);
    cr_assert_eq(pop(&s), 20);
    cr_assert_eq(pop(&s), 10);
    cr_assert_eq(pop(&s), -1); // Empty stack
    
    stack_clear(&s);
}

/* Swap Operation Test */
Test(stack_operations, swap_operations)
{
    t_stack s;
    int values[] = {1, 2};
    
    init_stack(&s, values, 2);
    cr_assert_eq(sa(&s), 0);
    cr_assert_eq(s.head->data, 2);
    cr_assert_eq(s.tail->data, 1);
    
    stack_clear(&s);
}

/* Edge Cases */
Test(stack_operations, edge_cases)
{
    // NULL stack
    cr_assert_eq(sa(NULL), 1);
    cr_assert_eq(pop(NULL), -1);
    
    // Empty stack
    t_stack s;
    stack_init(&s);
    cr_assert_eq(sa(&s), 1);
    cr_assert_eq(pop(&s), -1);
    stack_clear(&s);
}
=== ./includes/p_s_machine.h ===

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   p_s_machine.h                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kevin-anderson <kevin-anderson@student.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 15:46:44 by kevin-ander       #+#    #+#             */
/*   Updated: 2025/05/14 20:31:52 by kevin-ander      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   p_s_machine.h                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yourname <yourname@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 15:46:44 by yourname          #+#    #+#             */
/*   Updated: 2025/05/14 15:46:46 by yourname         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef P_S_MACHINE_H
# define P_S_MACHINE_H

# include <stdio.h>
# include <stdlib.h>

/* ========================
 * DEBUG CONFIGURATION
 * ======================== */
# ifndef DEBUG          // Allow override via compiler flag
#  define DEBUG 0       // 0=disabled, 1=enabled
# endif

/* ========================
 * OPERATION LOGGING MACRO
 * ======================== */
# define LOG_OPERATION(op, a, b) \
    do { \
        if (DEBUG) { \
            printf("--- %s ---\n", op); \
            print_stacks(op, a, b); \
        } \
    } while (0)

/* ========================
 * STACK STRUCTURES
 * ======================== */
typedef struct s_node {
    int             data;
    struct s_node   *next;
    struct s_node   *prev;
}   t_node;

typedef struct s_stack {
    t_node  *head;
    t_node  *tail;
    int     size;
    int     *shunting_array;
}   t_stack;

/* ========================
 * FUNCTION DECLARATIONS
 * ======================== */
void    print_stacks(const char *op_name, t_stack *a, t_stack *b);
// ... rest of your function declarations ...

#endif
=== ./src/p_s_machine.c ===

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   p_s_machine.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kevin-anderson <kevin-anderson@student.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 15:46:44 by kevin-ander       #+#    #+#             */
/*   Updated: 2025/05/14 20:44:07 by kevin-ander      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <stdlib.h>
#include "p_s_machine.h"
#include "p_s_machine.h"

void stack_init(t_stack *s)
{
    s->head = NULL;
    s->tail = NULL;
    s->size = 0;
    s->shunting_array = malloc(2 * sizeof(int));
    if (!s->shunting_array)
        printf("Memory error for shunting array!\n");
}

void stack_clear(t_stack *s)
{
    while (s->head)
    {
        t_node *tmp = s->head;
        s->head = s->head->next;
        free(tmp);
    }
    free(s->shunting_array);
    stack_init(s);
}

void push(t_stack *s, int data)
{
    t_node *new_node = malloc(sizeof(t_node));
    if (!new_node)
    {
        printf("Memory error!\n");
        return;
    }
    new_node->data = data;
    new_node->next = NULL;
    new_node->prev = NULL;
    if (s->head == NULL)
    {
        s->head = new_node;
        s->tail = new_node;
    }
    else
    {
        new_node->prev = s->tail;
        s->tail->next = new_node;
        s->tail = new_node;
    }
    s->size++;
}

int pop(t_stack *s)
{
    if (s->head == NULL)
    {
        printf("Stack is empty!\n");
        return -1;
    }
    int data = s->tail->data;
    if (s->head == s->tail)
    {
        free(s->tail);
        s->head = NULL;
        s->tail = NULL;
    }
    else
    {
        t_node *prev_node = s->tail->prev;
        prev_node->next = NULL;
        free(s->tail);
        s->tail = prev_node;
    }
    s->size--;
    return data;
}

void print_stacks(const char *op_name, t_stack *a, t_stack *b)
{
    if (!DEBUG) return;
    
    printf("--- %s ---\n", op_name);
    printf("Stack A [%d]: ", a->size);
    t_node *current_a = a->head;
    while (current_a)
    {
        printf("%d ", current_a->data);
        current_a = current_a->next;
    }
    printf("\nStack B [%d]: ", b->size);
    t_node *current_b = b->head;
    while (current_b)
    {
        printf("%d ", current_b->data);
        current_b = current_b->next;
    }
    printf("\n\n");
}

/* Swap Operations */
int swap_top_with_shunting(t_stack *s)
{
    if (!s || s->size < 2)
    {
        if (DEBUG) printf("Not enough elements to swap (size=%d)!\n", s ? s->size : 0);
        return 1;
    }
    
    if (!s->shunting_array)
    {
        if (DEBUG) printf("Shunting array not initialized!\n");
        return 1;
    }
    
    s->shunting_array[0] = pop(s);
    s->shunting_array[1] = pop(s);
    push(s, s->shunting_array[0]);
    push(s, s->shunting_array[1]);
    return 0;
}

int sa(t_stack *a) { return swap_top_with_shunting(a); }
int sb(t_stack *b) { return swap_top_with_shunting(b); }
int ss(t_stack *a, t_stack *b) { return sa(a) | sb(b); }

/* Push Operations */
int push_to(t_stack *dest, t_stack *src)
{
    if (src->size == 0)
    {
        printf("Source stack is empty!\n");
        return 1;
    }
    push(dest, pop(src));
    return 0;
}

int pa(t_stack *a, t_stack *b) { return push_to(a, b); }
int pb(t_stack *a, t_stack *b) { return push_to(b, a); }

/* Rotate Operations */
int rotate(t_stack *s)
{
    if (!s || s->size < 2)
    {
        printf("Not enough elements to rotate!\n");
        return 1;
    }
    
   t_node *first = s->head;
    s->head = first->next;
    s->head->prev = NULL;
    
    first->next = NULL;
    first->prev = s->tail;
    s->tail->next = first;
    s->tail = first;
    
    return 0;
}

int ra(t_stack *a) { return rotate(a); }
int rb(t_stack *b) { return rotate(b); }
int rr(t_stack *a, t_stack *b) { return ra(a) | rb(b); }

/* Reverse Rotate Operations */
int reverse_rotate(t_stack *s)
{
    if (!s || s->size < 2)
    {
        printf("Not enough elements to reverse rotate!\n");
        return 1;
    }
    
    t_node *last = s->tail;
    s->tail = last->prev;
    s->tail->next = NULL;
    
    last->prev = NULL;
    last->next = s->head;
    s->head->prev = last;
    s->head = last;
    
    return 0;
}

int rra(t_stack *a) { return reverse_rotate(a); }
int rrb(t_stack *b) { return reverse_rotate(b); }
int rrr(t_stack *a, t_stack *b) { return rra(a) | rrb(b); }

/* Main Test Function */
int main(void)
{
    t_stack a, b;
    stack_init(&a);
    stack_init(&b);

    printf("=== Initializing Stacks ===\n");
    for (int i = 1; i <= 3; i++) push(&a, i);
    for (int i = 4; i <= 6; i++) push(&b, i);
    print_stacks("Initial State", &a, &b);

    printf("=== Testing Swap Operations ===\n");
    sa(&a); print_stacks("sa", &a, &b);
    sb(&b); print_stacks("sb", &a, &b);
    ss(&a, &b); print_stacks("ss (should return to initial)", &a, &b);

    printf("=== Testing Push Operations ===\n");
    pa(&a, &b); print_stacks("pa (move from B to A)", &a, &b);
    pb(&a, &b); print_stacks("pb (move from A to B)", &a, &b);

    printf("=== Testing Rotate Operations ===\n");
    ra(&a); print_stacks("ra (rotate A)", &a, &b);
    rb(&b); print_stacks("rb (rotate B)", &a, &b);
    rr(&a, &b); print_stacks("rr (rotate both)", &a, &b);

    printf("=== Testing Reverse Rotate Operations ===\n");
    rra(&a); print_stacks("rra (reverse rotate A)", &a, &b);
    rrb(&b); print_stacks("rrb (reverse rotate B)", &a, &b);
    rrr(&a, &b); print_stacks("rrr (reverse rotate both)", &a, &b);

    printf("=== Final State ===\n");
    print_stacks("After all operations", &a, &b);

    stack_clear(&a);
    stack_clear(&b);
    return 0;
}
=== ./src/push_swap.c ===


=== ./src/operations.c ===


=== ./src/utils.c ===


=== ./Makefile ===

# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: kevin-anderson <kevin-anderson@student.    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/05/14 19:14:32 by kevin-ander       #+#    #+#              #
#    Updated: 2025/05/14 20:18:09 by kevin-ander      ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

# ========================
# 1. COMPILER CONFIGURATION
# ========================
CC          := cc
CFLAGS      := -Wall -Wextra -Werror
DEBUG       := -g
INCLUDES    := -I./includes -I./tests/test_utils
LDFLAGS     := -fprofile-arcs -ftest-coverage

# ========================
# 2. LIBRARIES & TOOLS
# ========================
CRITERION   := -lcriterion
COV_FLAGS   := -fprofile-arcs -ftest-coverage
GCOV        := gcov
LCOV        := lcov
GENHTML     := genhtml
LCOV_IGNORE := --ignore-errors empty,inconsistent,source
GENHTML_IGNORE := --ignore-errors source

# ========================
# 3. PROJECT STRUCTURE
# ========================
NAME        := push_swap
TEST_NAME   := test_stack
SRC_DIR     := src
TEST_DIR    := tests
OBJ_DIR     := obj
COV_DIR     := coverage

# ========================
# 4. SOURCE FILES
# ========================
CORE_FILES  := p_s_machine.c operations.c utils.c
MAIN_FILE   := push_swap.c
TEST_FILES  := test_stack_ops.c test_utils/test_helpers.c

# ========================
# 5. GENERATED PATHS
# ========================
SRCS        := $(addprefix $(SRC_DIR)/,$(CORE_FILES) $(MAIN_FILE))
OBJS        := $(addprefix $(OBJ_DIR)/,$(CORE_FILES:.c=.o) $(MAIN_FILE:.c=.o))
TEST_SRCS   := $(addprefix $(TEST_DIR)/,$(TEST_FILES))
TEST_OBJS   := $(addprefix $(OBJ_DIR)/,$(TEST_FILES:.c=.o))

# ========================
# 6. OUTPUT COLORS
# ========================
GREEN       := \033[0;32m
RED         := \033[0;31m
YELLOW      := \033[0;33m
NC          := \033[0m

# ========================
# 7. MAIN BUILD RULES
# ========================
all: $(NAME)

$(NAME): $(OBJS)
	@echo "$(YELLOW)Linking $(NAME)...$(NC)"
	@$(CC) $(CFLAGS) $(DEBUG) $(OBJS) -o $(NAME) $(LDFLAGS)
	@echo "$(GREEN)$(NAME) compiled successfully!$(NC)"

# ========================
# 8. COMPILATION RULES
# ========================
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c | $(OBJ_DIR)
	@mkdir -p $(@D)
	@echo "$(YELLOW)Compiling $<...$(NC)"
	@$(CC) $(CFLAGS) $(DEBUG) $(INCLUDES) -c $< -o $@ $(COV_FLAGS)

$(OBJ_DIR)/%.o: $(TEST_DIR)/%.c | $(OBJ_DIR)
	@mkdir -p $(@D)
	@echo "$(YELLOW)Compiling $<...$(NC)"
	@$(CC) $(CFLAGS) $(DEBUG) $(INCLUDES) -c $< -o $@ $(COV_FLAGS)

$(OBJ_DIR):
	@mkdir -p $(OBJ_DIR)

# ========================
# 9. TESTING RULES
# ========================
test: $(TEST_NAME)
	@./$(TEST_NAME)

$(TEST_NAME): $(filter-out $(OBJ_DIR)/$(MAIN_FILE:.c=.o),$(OBJS)) $(TEST_OBJS)
	@echo "$(YELLOW)Building tests...$(NC)"
	@$(CC) $(CFLAGS) $(DEBUG) $(INCLUDES) $^ -o $(TEST_NAME) $(CRITERION) $(COV_FLAGS)
	@echo "$(GREEN)Tests compiled successfully!$(NC)"

# ========================
# 10. COVERAGE REPORT 
# ========================
coverage: test
	@echo "$(YELLOW)Generating coverage report...$(NC)"
	@mkdir -p $(COV_DIR)
	@# First reset counters
	@$(LCOV) --zerocounters --directory $(OBJ_DIR)
	@# Run tests to generate fresh coverage data
	@./$(TEST_NAME) > /dev/null 2>&1
	@# Capture coverage with all necessary ignores
	@if ! $(LCOV) --capture \
		--directory $(OBJ_DIR) \
		--output-file $(COV_DIR)/coverage.info \
		--no-external \
		--exclude '*/tests/*' \
		--exclude '*/usr/include/*' \
		--ignore-errors unused \
		--ignore-errors empty \
		--ignore-errors inconsistent; then \
		echo "$(YELLOW)Coverage generation completed with warnings$(NC)"; \
	fi
	@# Generate HTML report
	@if ! $(GENHTML) $(COV_DIR)/coverage.info \
		--output-directory $(COV_DIR) \
		--ignore-errors source; then \
		echo "$(YELLOW)HTML generation completed with warnings$(NC)"; \
	fi
	@echo "$(GREEN)Coverage report generated in $(COV_DIR)/$(NC)"
	@xdg-open $(COV_DIR)/index.html 2>/dev/null || \
	 open $(COV_DIR)/index.html 2>/dev/null || \
	 echo "Open $(COV_DIR)/index.html in your browser"
	 
# ========================
# 11. CLEANING RULES
# ========================
clean:
	@find . -name "*.gcda" -delete
	@find . -name "*.gcno" -delete
	@rm -rf $(OBJ_DIR)
	@echo "$(RED)Object files and coverage data removed$(NC)"

fclean: clean
	@rm -f $(NAME) $(TEST_NAME)
	@rm -rf $(COV_DIR)
	@echo "$(RED)Executables and coverage reports removed$(NC)"

re: fclean all

.PHONY: all clean fclean re test coverage
